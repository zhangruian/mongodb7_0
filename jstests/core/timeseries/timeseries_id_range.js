/**
 * Verifies that the we can internalize match predicates generated by time series rewrites on _id as
 * range scan using a combination of minRecord and maxRecord.
 *
 * @tags: [
 *     assumes_no_implicit_collection_creation_after_drop,
 *     does_not_support_transactions,
 *     requires_fcv_49,
 *     requires_find_command,
 *     requires_getmore,
 *     requires_wiredtiger,
 * ]
 */
(function() {
"use strict";

load('jstests/libs/analyze_plan.js');
load("jstests/core/timeseries/libs/timeseries.js");

if (!TimeseriesTest.timeseriesCollectionsEnabled(db.getMongo())) {
    jsTestLog("Skipping test because the time-series collection feature flag is disabled");
    return;
}

const now = new Date();
const dates = [];
for (let i = 0; i < 10; i++) {
    let d = new Date();
    d.setDate(now.getDate() + (i - 5));
    dates.push(d);
}

const coll = db.timeseries_id_range;
const timeFieldName = "time";

function init() {
    coll.drop();

    assert.commandWorked(
        db.createCollection(coll.getName(), {timeseries: {timeField: timeFieldName}}));
}

(function testEQ() {
    init();

    let expl = assert.commandWorked(db.runCommand({
        explain: {
            update: "system.buckets.timeseries_id_range",
            updates: [{q: {"_id": dates[5]}, u: {$set: {a: 1}}}]
        }
    }));

    assert(dates[5], getPlanStage(expl, "COLLSCAN").minRecord);
    assert(dates[5], getPlanStage(expl, "COLLSCAN").maxRecord);
})();

(function testLTE() {
    init();
    // Just for this test, use a more complex pipeline with unwind.
    const pipeline = [{$match: {time: {$lte: dates[5]}}}, {$unwind: '$x'}];
    let res = coll.aggregate(pipeline).toArray();
    assert.eq(0, res.length);

    let expl = coll.explain("executionStats").aggregate(pipeline);
    assert(getAggPlanStage(expl, "COLLSCAN").hasOwnProperty("maxRecord"));
    assert.eq(0, expl.stages[0].$cursor.executionStats.executionStages.nReturned);

    for (let i = 0; i < 10; i++) {
        assert.commandWorked(coll.insert({_id: i, [timeFieldName]: dates[i], x: [1, 2]}));
    }

    res = coll.aggregate(pipeline).toArray();
    assert.eq(12, res.length);

    expl = coll.explain("executionStats").aggregate(pipeline);
    assert.eq(7, expl.stages[0].$cursor.executionStats.totalDocsExamined);
})();

(function testLT() {
    init();
    const pipeline = [{$match: {time: {$lt: dates[5]}}}];
    let res = coll.aggregate(pipeline).toArray();
    assert.eq(0, res.length);

    let expl = coll.explain("executionStats").aggregate(pipeline);
    assert(getAggPlanStage(expl, "COLLSCAN").hasOwnProperty("maxRecord"));
    assert.eq(0, expl.stages[0].$cursor.executionStats.executionStages.nReturned);

    for (let i = 0; i < 10; i++) {
        assert.commandWorked(coll.insert({_id: i, [timeFieldName]: dates[i]}));
    }

    res = coll.aggregate(pipeline).toArray();
    assert.eq(5, res.length);

    expl = coll.explain("executionStats").aggregate(pipeline);
    assert.eq(6, expl.stages[0].$cursor.executionStats.totalDocsExamined);
})();

(function testGTE() {
    init();
    const pipeline = [{$match: {time: {$gte: dates[5]}}}];
    let res = coll.aggregate(pipeline).toArray();
    assert.eq(0, res.length);

    let expl = coll.explain("executionStats").aggregate(pipeline);
    assert(getAggPlanStage(expl, "COLLSCAN").hasOwnProperty("minRecord"));
    assert.eq(0, expl.stages[0].$cursor.executionStats.executionStages.nReturned);

    for (let i = 0; i < 10; i++) {
        assert.commandWorked(coll.insert({_id: i, [timeFieldName]: dates[i]}));
    }

    res = coll.aggregate(pipeline).toArray();
    assert.eq(5, res.length);

    expl = coll.explain("executionStats").aggregate(pipeline);
    assert.eq(6, expl.stages[0].$cursor.executionStats.totalDocsExamined);
})();

(function testGT() {
    init();
    const pipeline = [{$match: {time: {$gt: dates[5]}}}];
    let res = coll.aggregate(pipeline).toArray();
    assert.eq(0, res.length);

    let expl = coll.explain("executionStats").aggregate(pipeline);
    assert(getAggPlanStage(expl, "COLLSCAN").hasOwnProperty("minRecord"));
    assert.eq(0, expl.stages[0].$cursor.executionStats.executionStages.nReturned);

    for (let i = 0; i < 10; i++) {
        assert.commandWorked(coll.insert({_id: i, [timeFieldName]: dates[i]}));
    }

    res = coll.aggregate(pipeline).toArray();
    assert.eq(4, res.length);

    expl = coll.explain("executionStats").aggregate(pipeline);
    assert.eq(6, expl.stages[0].$cursor.executionStats.totalDocsExamined);
})();

(function testRange1() {
    init();

    const pipeline = [{$match: {time: {$gte: dates[5], $lte: dates[7]}}}];
    let res = coll.aggregate(pipeline).toArray();
    assert.eq(0, res.length);

    let expl = coll.explain("executionStats").aggregate(pipeline);
    assert(getAggPlanStage(expl, "COLLSCAN").hasOwnProperty("minRecord"));
    assert(getAggPlanStage(expl, "COLLSCAN").hasOwnProperty("maxRecord"));
    assert.eq(0, expl.stages[0].$cursor.executionStats.executionStages.nReturned);

    for (let i = 0; i < 10; i++) {
        assert.commandWorked(coll.insert({_id: i, [timeFieldName]: dates[i]}));
    }

    res = coll.aggregate(pipeline).toArray();
    assert.eq(3, res.length);

    expl = coll.explain("executionStats").aggregate(pipeline);
    assert.eq(5, expl.stages[0].$cursor.executionStats.totalDocsExamined);
})();

(function testRange2() {
    init();

    const pipeline = [{$match: {time: {$gt: dates[5], $lt: dates[7]}}}];
    let res = coll.aggregate(pipeline).toArray();
    assert.eq(0, res.length);

    let expl = coll.explain("executionStats").aggregate(pipeline);
    assert(getAggPlanStage(expl, "COLLSCAN").hasOwnProperty("minRecord"));
    assert(getAggPlanStage(expl, "COLLSCAN").hasOwnProperty("maxRecord"));
    assert.eq(0, expl.stages[0].$cursor.executionStats.executionStages.nReturned);

    for (let i = 0; i < 10; i++) {
        assert.commandWorked(coll.insert({_id: i, [timeFieldName]: dates[i]}));
    }

    res = coll.aggregate(pipeline).toArray();
    assert.eq(1, res.length);

    expl = coll.explain("executionStats").aggregate(pipeline);
    assert.eq(4, expl.stages[0].$cursor.executionStats.totalDocsExamined);
})();

(function testRange3() {
    init();

    const pipeline = [{$match: {time: {$lt: dates[5], $gt: dates[7]}}}];
    let res = coll.aggregate(pipeline).toArray();
    assert.eq(0, res.length);

    let expl = coll.explain("executionStats").aggregate(pipeline);
    assert(getAggPlanStage(expl, "COLLSCAN").hasOwnProperty("minRecord"));
    assert(getAggPlanStage(expl, "COLLSCAN").hasOwnProperty("maxRecord"));
    assert.eq(0, expl.stages[0].$cursor.executionStats.executionStages.nReturned);

    for (let i = 0; i < 10; i++) {
        assert.commandWorked(coll.insert({_id: i, [timeFieldName]: dates[i]}));
    }

    res = coll.aggregate(pipeline).toArray();
    assert.eq(0, res.length);

    expl = coll.explain("executionStats").aggregate(pipeline);
    assert.eq(1, expl.stages[0].$cursor.executionStats.totalDocsExamined);
})();

(function testRange4() {
    init();

    const pipeline = [{$match: {time: {$gte: dates[3], $gt: dates[5], $lt: dates[7]}}}];
    let res = coll.aggregate(pipeline).toArray();
    assert.eq(0, res.length);

    let expl = coll.explain("executionStats").aggregate(pipeline);
    assert(getAggPlanStage(expl, "COLLSCAN").hasOwnProperty("minRecord"));
    assert(getAggPlanStage(expl, "COLLSCAN").hasOwnProperty("maxRecord"));
    assert.eq(0, expl.stages[0].$cursor.executionStats.executionStages.nReturned);

    for (let i = 0; i < 10; i++) {
        assert.commandWorked(coll.insert({_id: i, [timeFieldName]: dates[i]}));
    }

    res = coll.aggregate(pipeline).toArray();
    assert.eq(1, res.length);

    expl = coll.explain("executionStats").aggregate(pipeline);
    assert.eq(4, expl.stages[0].$cursor.executionStats.totalDocsExamined);
})();
})();
