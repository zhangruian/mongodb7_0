/**
 * Utility for checking that the aggregated telemetry metrics are logical (follows sum >= max >=
 * min, and sum = max = min if only one execution).
 */
function verifyMetrics(batch) {
    batch.forEach(element => {
        if (element.metrics.execCount === 1) {
            for (const [metricName, summaryValues] of Object.entries(element.metrics)) {
                // Skip over fields that aren't aggregated metrics with sum/min/max (execCount,
                // lastExecutionMicros).
                if (summaryValues.sum === undefined) {
                    continue;
                }
                const debugInfo = {[metricName]: summaryValues};
                // If there has only been one execution, all metrics should have min, max, and sum
                // equal to each other.
                assert.eq(summaryValues.sum, summaryValues.min, debugInfo);
                assert.eq(summaryValues.sum, summaryValues.max, debugInfo);
                assert.eq(summaryValues.min, summaryValues.max, debugInfo);
            }
        } else {
            for (const [metricName, summaryValues] of Object.entries(element.metrics)) {
                // Skip over fields that aren't aggregated metrics with sum/min/max (execCount,
                // lastExecutionMicros).
                if (summaryValues.sum === undefined) {
                    continue;
                }
                const debugInfo = {[metricName]: summaryValues};
                assert.gte(summaryValues.sum, summaryValues.min, debugInfo);
                assert.gte(summaryValues.sum, summaryValues.max, debugInfo);
                assert.lte(summaryValues.min, summaryValues.max, debugInfo);
            }
        }
    });
}

/**
 *
 * Collect telemetry from a given collection. Only include query shapes generated by the shell that
 * is running tests.
 *
 */
function getTelemetry(conn) {
    const kApplicationName = "MongoDB Shell";
    const result = conn.adminCommand({
        aggregate: 1,
        pipeline: [
            {$telemetry: {}},
            // Sort on telemetry key so entries are in a deterministic order.
            {$sort: {key: 1}},
            {$match: {"key.applicationName": kApplicationName}}
        ],
        cursor: {}
    });
    assert.commandWorked(result);
    return result.cursor.firstBatch;
}

function getTelemetryRedacted(
    conn,
    applyHmacToIdentifiers = true,
    hmacKey = BinData(0, "MjM0NTY3ODkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjE=")) {
    // Hashed application name is generated using the default hmacKey argument.
    const kApplicationName = "T1iwlAqhXYroi7HTycmBJvWZSETwKXnaNa5akM4q0H4=";
    // Filter out agg queries, including $telemetry.
    const match = {
        $match: {"key.queryShape.find": {$exists: true}, "key.applicationName": kApplicationName}
    };
    if (!applyHmacToIdentifiers) {
        match.$match["key.applicationName"] = "MongoDB Shell";
    }

    const result = conn.adminCommand({
        aggregate: 1,
        pipeline: [
            {$telemetry: {applyHmacToIdentifiers: applyHmacToIdentifiers, hmacKey: hmacKey}},
            match,
            // Sort on telemetry key so entries are in a deterministic order.
            {$sort: {key: 1}},
        ],
        cursor: {}
    });
    assert.commandWorked(result);
    return result.cursor.firstBatch;
}

/**
 * @param {object} conn - connection to database
 * @param {object} options {
 *  {String} collName - name of collection
 *  {boolean} applyHmacToIdentifiers - whether or not to redact identifiers
 * }
 */
function getTelemetryFindCmd(conn, options = {
    collName: "",
    applyHmacToIdentifiers: false,
}) {
    // Filter out agg queries, including $queryStats.
    let matchExpr = {"key.find": {$exists: true}, "key.client.application.name": "MongoDB Shell"};
    if (options.collName) {
        matchExpr["key.cmdNs.coll"] = options.collName;
    }
    const pipeline = [
        {$telemetry: {applyHmacToIdentifiers: options.applyHmacToIdentifiers}},
        {$match: matchExpr},
        // Sort on queryStats key so entries are in a deterministic order.
        {$sort: {key: 1}},
    ];
    const result = conn.adminCommand({aggregate: 1, pipeline: pipeline, cursor: {}});
    assert.commandWorked(result);
    return result.cursor.firstBatch;
}
