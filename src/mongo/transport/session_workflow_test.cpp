/**
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 */


#include "mongo/platform/basic.h"

#include <array>
#include <deque>
#include <initializer_list>
#include <memory>
#include <type_traits>
#include <utility>
#include <vector>

#include "mongo/base/checked_cast.h"
#include "mongo/base/status.h"
#include "mongo/bson/bsonobj.h"
#include "mongo/bson/bsonobjbuilder.h"
#include "mongo/db/client.h"
#include "mongo/db/client_strand.h"
#include "mongo/db/concurrency/locker_noop_service_context_test_fixture.h"
#include "mongo/db/dbmessage.h"
#include "mongo/db/service_context.h"
#include "mongo/logv2/log.h"
#include "mongo/platform/compiler.h"
#include "mongo/platform/mutex.h"
#include "mongo/rpc/op_msg.h"
#include "mongo/stdx/variant.h"
#include "mongo/transport/mock_session.h"
#include "mongo/transport/service_entry_point.h"
#include "mongo/transport/service_entry_point_impl.h"
#include "mongo/transport/service_executor.h"
#include "mongo/transport/service_executor_utils.h"
#include "mongo/transport/session_workflow.h"
#include "mongo/transport/session_workflow_test_util.h"
#include "mongo/unittest/unittest.h"
#include "mongo/util/assert_util.h"
#include "mongo/util/concurrency/notification.h"
#include "mongo/util/concurrency/thread_pool.h"
#include "mongo/util/synchronized_value.h"

#define MONGO_LOGV2_DEFAULT_COMPONENT ::mongo::logv2::LogComponent::kTest

namespace mongo::transport {
namespace {

const Status kClosedSessionError{ErrorCodes::SocketException, "Session is closed"};
const Status kNetworkError{ErrorCodes::HostUnreachable, "Someone is unreachable"};
const Status kShutdownError{ErrorCodes::ShutdownInProgress, "Something is shutting down"};
const Status kArbitraryError{ErrorCodes::InternalError, "Something happened"};

template <typename T, size_t N>
StringData findEnumName(const std::pair<T, StringData> (&arr)[N], T k) {
    using std::begin;
    using std::end;
    return std::find_if(begin(arr), end(arr), [&](auto&& e) { return e.first == k; })->second;
}

/**
 * Events generated by SessionWorkflow via virtual function calls to mock
 * objects. They are a means to observe and indirectly manipulate
 * SessionWorkflow's behavior to reproduce test scenarios.
 *
 * They are named for the mock object and function that emits them.
 */
enum class Event {
    kSessionWaitForData,
    kSessionSourceMessage,
    kSepHandleRequest,
    kSessionSinkMessage,
    kSepEndSession,
};

StringData toString(Event e) {
    return findEnumName(
        {
            {Event::kSessionWaitForData, "Session.waitForData"_sd},
            {Event::kSessionSourceMessage, "Session.sourceMessage"_sd},
            {Event::kSepHandleRequest, "Sep.handleRequest"_sd},
            {Event::kSessionSinkMessage, "Session.sinkMessage"_sd},
            {Event::kSepEndSession, "Sep.endSession"_sd},
        },
        e);
}

std::ostream& operator<<(std::ostream& os, Event e) {
    return os << toString(e);
}


template <typename T>
static std::string typeName() {
    return demangleName(typeid(T));
}
template <typename T>
static std::ostream& stream(std::ostream& os, const T&) {
    return os << "[{}]"_format(typeName<T>());
}
static std::ostream& stream(std::ostream& os, const Status& v) {
    return os << v;
}
template <typename T>
static std::ostream& stream(std::ostream& os, const StatusWith<T>& v) {
    if (!v.isOK())
        return stream(os, v.getStatus());
    return stream(os, v.getValue());
}

class Result {
    using Variant = stdx::variant<stdx::monostate, Status, StatusWith<Message>, Future<DbResponse>>;

public:
    Result() = default;

    Result(Result&&) = default;
    Result& operator=(Result&&) = default;

    template <typename T, std::enable_if_t<std::is_constructible_v<Variant, T&&>, int> = 0>
    explicit Result(T&& v) : _value{std::forward<T>(v)} {}

    template <typename T>
    T consumeAs() && {
        return stdx::visit(
            [](auto&& alt) -> T {
                using A = decltype(alt);
                if constexpr (std::is_convertible<A, T>())
                    return std::forward<A>(alt);
                invariant(0, "{} => {}"_format(typeName<A>(), typeName<T>()));
                MONGO_UNREACHABLE;
            },
            std::exchange(_value, {}));
    }

    explicit operator bool() const {
        return _value.index() != 0;
    }

private:
    friend std::string toString(const Result& r) {
        return stdx::visit(
            [](auto&& alt) -> std::string {
                using A = std::decay_t<decltype(alt)>;
                std::ostringstream os;
                stream(os << "[{}]"_format(typeName<A>()), alt);
                return os.str();
            },
            r._value);
    }

    Variant _value;
};

Message makeOpMsg() {
    static auto nextId = AtomicWord<int>{0};
    auto omb = OpMsgBuilder{};
    omb.setBody(BSONObjBuilder{}.append("id", nextId.fetchAndAdd(1)).obj());
    return omb.finish();
}

DbResponse makeResponse(Message m) {
    DbResponse response{};
    response.response = m;
    return response;
}

DbResponse setExhaust(DbResponse response) {
    response.shouldRunAgainForExhaust = true;
    return response;
}

Message setExhaustSupported(Message msg) {
    OpMsg::setFlag(&msg, OpMsg::kExhaustSupported);
    return msg;
}

Message setMoreToCome(Message msg) {
    OpMsg::setFlag(&msg, OpMsg::kMoreToCome);
    return msg;
}

/** Fixture that mocks interactions with a `SessionWorkflow`. */
class SessionWorkflowTest : public LockerNoopServiceContextTest {
    using Base = LockerNoopServiceContextTest;

public:
    void setUp() override {
        Base::setUp();
        auto sc = getServiceContext();
        sc->setServiceEntryPoint(_makeServiceEntryPoint(sc));
        initializeNewSession();
        invariant(sep()->start());
        _threadPool->startup();
    }

    void tearDown() override {
        ScopeGuard guard = [&] { Base::tearDown(); };
        // Normal shutdown is a noop outside of ASAN.
        invariant(sep()->shutdownAndWait(Seconds{10}));
        _threadPool->shutdown();
        _threadPool->join();
    }

    void initializeNewSession() {
        _session = std::make_shared<CustomMockSession>(this);
    }

    /** Waits for the current Session and SessionWorkflow to end. */
    void joinSessions() {
        ASSERT(sep()->waitForNoSessions(Seconds{1}));
    }

    /** Launches a SessionWorkflow for the current session. */
    void startSession() {
        LOGV2(6742613, "Starting session");
        sep()->startSession(_session);
    }

    MockServiceEntryPoint* sep() {
        return checked_cast<MockServiceEntryPoint*>(getServiceContext()->getServiceEntryPoint());
    }

    /**
     * Installs an arbitrary one-shot mock handler callback for the next event.
     * The next incoming mock event will invoke this callback and destroy it.
     */
    void injectMockResponse(unique_function<Result(Event)> cb) {
        _expect.push(std::move(cb));
    }

    /**
     * Wrapper around `injectMockResponse`. Installs a handler for the `expected`
     * mock event, that will return the specified `result`.
     * Returns a `Future` that is fulfilled when that mock event occurs.
     */
    Future<void> asyncExpect(Event expected, Result r) {
        auto pf = std::make_shared<PromiseAndFuture<void>>();
        injectMockResponse([r = std::move(r), expected, pf](Event event) mutable {
            invariant(event == expected,
                      "Expected {}, but got {}"_format(toString(expected), toString(event)));
            pf->promise.emplaceValue();
            return std::move(r);
        });
        return std::move(pf->future);
    }

    void expect(Event expected, Result r) {
        return asyncExpect(expected, std::move(r)).get();
    }

private:
    class MockExpectationSlot {
    public:
        void push(unique_function<Result(Event)> cb) {
            stdx::lock_guard lk{_mutex};
            invariant(!_cb);
            _cb = std::move(cb);
            _cv.notify_one();
        }

        unique_function<Result(Event)> pop() {
            stdx::unique_lock lk{_mutex};
            _cv.wait(lk, [&] { return !!_cb; });
            return std::exchange(_cb, {});
        }

    private:
        mutable Mutex _mutex;
        stdx::condition_variable _cv;
        unique_function<Result(Event)> _cb;
    };

    class CustomMockSession : public CallbackMockSession {
    public:
        explicit CustomMockSession(SessionWorkflowTest* fixture) {
            endCb = [this] { *_connected = false; };
            isConnectedCb = [this] { return *_connected; };
            waitForDataCb = [fixture] {
                return fixture->_onMockEvent<Status>(Event::kSessionWaitForData);
            };
            sourceMessageCb = [fixture] {
                return fixture->_onMockEvent<StatusWith<Message>>(Event::kSessionSourceMessage);
            };
            sinkMessageCb = [fixture](Message) {
                return fixture->_onMockEvent<Status>(Event::kSessionSinkMessage);
            };
            // The async variants will just run the same callback on `_threadPool`.
            auto async = [fixture](auto cb) {
                return ExecutorFuture<void>(fixture->_threadPool).then(cb).unsafeToInlineFuture();
            };
            asyncWaitForDataCb = [=, cb = waitForDataCb] { return async([cb] { return cb(); }); };
            asyncSourceMessageCb = [=, cb = sourceMessageCb](const BatonHandle&) {
                return async([cb] { return cb(); });
            };
            asyncSinkMessageCb = [=, cb = sinkMessageCb](Message m, const BatonHandle&) {
                return async([cb, m = std::move(m)]() mutable { return cb(std::move(m)); });
            };
        }

    private:
        synchronized_value<bool> _connected{true};  // Born in the connected state.
    };

    std::shared_ptr<ThreadPool> _makeThreadPool() {
        ThreadPool::Options options{};
        options.poolName = "SessionWorkflowTest";
        return std::make_shared<ThreadPool>(std::move(options));
    }

    /**
     * Simulates an async command implemented under the borrowed thread model.
     * The promise must be fulfilled while holding ClientStrand.
     */
    Future<DbResponse> _asyncHandleRequest(OperationContext* opCtx,
                                           unique_function<Future<DbResponse>()> cb) {
        auto pf = PromiseAndFuture<DbResponse>();
        ExecutorFuture<void>(_threadPool)
            .then([strand = ClientStrand::get(opCtx->getClient()),
                   cb = std::move(cb),
                   p = std::move(pf.promise)]() mutable {
                strand->run([&] { p.setWith([&] { return cb(); }); });
            })
            .getAsync([](auto&&) {});
        return std::move(pf.future);
    }

    std::unique_ptr<MockServiceEntryPoint> _makeServiceEntryPoint(ServiceContext* sc) {
        auto sep = std::make_unique<MockServiceEntryPoint>(sc);
        sep->handleRequestCb = [=](OperationContext* opCtx, const Message&) {
            auto cb = [this] { return _onMockEvent<Future<DbResponse>>(Event::kSepHandleRequest); };
            if (!gInitialUseDedicatedThread)
                return _asyncHandleRequest(opCtx, std::move(cb));
            return cb();
        };
        sep->onEndSessionCb = [=](const SessionHandle&) {
            _onMockEvent<void>(Event::kSepEndSession);
        };
        sep->derivedOnClientDisconnectCb = [&](Client*) {};
        return sep;
    }

    /**
     * Called by all mock functions to notify the main thread and get a value with which to respond.
     * The mock function call is identified by an `event`.  If there isn't already an expectation,
     * the mock object will wait for one to be injected via a call to `injectMockResponse`.
     */
    template <typename Target>
    Target _onMockEvent(Event event) {
        LOGV2_DEBUG(6742616, 2, "Mock event arrived", "event"_attr = event);
        Result r = _expect.pop()(event);
        LOGV2_DEBUG(6742618, 2, "Responding", "event"_attr = event, "result"_attr = toString(r));
        if constexpr (std::is_same_v<Target, void>) {
            std::move(r).consumeAs<stdx::monostate>();
            return;
        } else {
            return std::move(r).consumeAs<Target>();
        }
    }

    MockExpectationSlot _expect;
    std::shared_ptr<CustomMockSession> _session;
    std::shared_ptr<ThreadPool> _threadPool = _makeThreadPool();
};

TEST_F(SessionWorkflowTest, StartThenEndSession) {
    startSession();
    expect(Event::kSessionSourceMessage, Result{kClosedSessionError});
    expect(Event::kSepEndSession, Result{});
    joinSessions();
}

TEST_F(SessionWorkflowTest, OneNormalCommand) {
    startSession();
    expect(Event::kSessionSourceMessage, Result{makeOpMsg()});
    expect(Event::kSepHandleRequest, Result{makeResponse(makeOpMsg())});
    expect(Event::kSessionSinkMessage, Result{Status::OK()});
    expect(Event::kSessionSourceMessage, Result{kClosedSessionError});
    expect(Event::kSepEndSession, Result{});
    joinSessions();
}

TEST_F(SessionWorkflowTest, OnClientDisconnectCalledOnCleanup) {
    int disconnects = 0;
    sep()->derivedOnClientDisconnectCb = [&](Client*) { ++disconnects; };
    startSession();
    ASSERT_EQ(disconnects, 0);
    expect(Event::kSessionSourceMessage, Result{kClosedSessionError});
    expect(Event::kSepEndSession, Result{});
    joinSessions();
    ASSERT_EQ(disconnects, 1);
}

/** Repro of one formerly troublesome scenario generated by the StepRunner test below. */
TEST_F(SessionWorkflowTest, MoreToComeDisconnectAtSource3) {
    startSession();
    // One more-to-come command, yields an empty response per wire protocol
    expect(Event::kSessionSourceMessage, Result{setMoreToCome(makeOpMsg())});
    expect(Event::kSepHandleRequest, Result{makeResponse({})});
    // Another message from session, this time a normal RPC.
    expect(Event::kSessionSourceMessage, Result{makeOpMsg()});
    expect(Event::kSepHandleRequest, Result{makeResponse(makeOpMsg())});
    expect(Event::kSessionSinkMessage, Result{Status::OK()});
    // Client disconnects while we're waiting for their next command.
    expect(Event::kSessionSourceMessage, Result{kShutdownError});
    expect(Event::kSepEndSession, Result{});
    joinSessions();
}

/**
 * Check the behavior of an interrupted "getMore" exhaust command.
 * SessionWorkflow looks specifically for the "getMore" command name to trigger
 * this cleanup.
 */
TEST_F(SessionWorkflowTest, CleanupFromGetMore) {
    // For this test, SEP handleRequest will stash a copy of the request.
    // When a handleRequest has been observed, the test can check this variable
    // to peek at it.
    auto stashedRequest = std::make_shared<synchronized_value<Message>>();
    sep()->handleRequestCb = [orig = sep()->handleRequestCb,
                              stashedRequest](OperationContext* opCtx, const Message& msg) {
        **stashedRequest = msg;
        return orig(opCtx, msg);
    };

    initializeNewSession();
    startSession();

    auto makeGetMoreRequest = [](int64_t cursorId) {
        OpMsgBuilder omb;
        omb.setBody(BSONObjBuilder{}
                        .append("getMore", cursorId)
                        .append("collection", "testColl")
                        .append("$db", "testDb")
                        .obj());
        return setExhaustSupported(omb.finish());
    };

    auto makeGetMoreResponse = [] {
        DbResponse response;
        OpMsgBuilder omb;
        omb.setBody(BSONObjBuilder{}.append("id", int64_t{0}).obj());
        response.response = omb.finish();
        return response;
    };

    // Produce the condition of having an active `getMore` exhaust command.
    expect(Event::kSessionSourceMessage, Result{makeGetMoreRequest(123)});
    expect(Event::kSepHandleRequest, Result{setExhaust(makeGetMoreResponse())});

    // Simulate a disconnect during the session sink call. The cleanup of
    // exhaust resources happens when the session disconnects. So after the send
    // of the "getMore" response returns the injected error, expect the
    // SessionWorkflow to issue a fire-and-forget "killCursors".
    expect(Event::kSessionSinkMessage, Result{kClosedSessionError});
    {
        auto killCursors = std::make_shared<Notification<Message>>();
        auto unpause = std::make_shared<Notification<void>>();
        ScopeGuard unpauseGuard = [&] { unpause->set(); };
        injectMockResponse([killCursors, unpause, stashedRequest](Event e) {
            invariant(e == Event::kSepHandleRequest);
            killCursors->set(**stashedRequest);
            unpause->get();                   // Pause while main thread examines killCursors.
            return Result{makeResponse({})};  // fire-and-forget disallows response.
        });
        ASSERT_EQ(OpMsgRequest::parse(killCursors->get()).getCommandName(), "killCursors"_sd);
    }
    // Because they're fire-and-forget commands, we will only observe `handleRequest`
    // calls to the SEP for the cleanup "killCursors", and the next thing to happen
    // will be the end of the session.
    expect(Event::kSepEndSession, Result{});
    joinSessions();
}


class StepRunnerSessionWorkflowTest : public SessionWorkflowTest {
public:
    /**
     * Concisely encode the ways this test might respond to mock events.
     * The OK Result contents depend on which Event it's responding to.
     */
    enum class Action {
        kDefault,     // OK result for a basic (request and response) command.
        kExhaust,     // OK result for a exhuast command.
        kMoreToCome,  // OK result for a fire-and-forget command.

        kErrTerminate,   // External termination via the ServiceEntryPoint.
        kErrDisconnect,  // Socket disconnection by peer.
        kErrNetwork,     // Unspecified network failure (ala host unreachable).
        kErrShutdown,    // System shutdown.
        kErrArbitrary,   // An arbitrary error that does not fall under the other conditions.
    };

    friend StringData toString(Action k) {
        return findEnumName({{Action::kDefault, "Default"_sd},
                             {Action::kExhaust, "Exhaust"_sd},
                             {Action::kMoreToCome, "MoreToCome"_sd},
                             {Action::kErrTerminate, "ErrTerminate"_sd},
                             {Action::kErrDisconnect, "ErrDisconnect"_sd},
                             {Action::kErrNetwork, "ErrNetwork"_sd},
                             {Action::kErrShutdown, "ErrShutdown"_sd},
                             {Action::kErrArbitrary, "ErrArbitrary"_sd}},
                            k);
    }

    /**
     * Given a list of steps, performs a series of tests exercising that list.
     *
     * The `run()` function performs a set of variations on the steps, failing
     * further and further along the way, with different errors tried at each
     * step.
     *
     * It first sets a baseline by running all the steps without injecting
     * failure. Then it checks each failure condition for each step in the
     * sequence. For example, if we have steps[NS] and failure conditions
     * fails[NF], it will run these pseudocode trials:
     *
     *   // First, no errors.
     *   { steps[0](OK); steps[1](OK); ... steps[NS-1](OK); }
     *
     *   // Inject each kind of failure at steps[0].
     *   { steps[0](fails[0]); }
     *   { steps[0](fails[1]); }
     *   ... and so on for fails[NF].
     *
     *   // Now let steps[0] succeed, but inject each kind of failure at steps[1].
     *   { steps[0](OK); steps[1](fails[0]); }
     *   { steps[0](OK); steps[1](fails[1]); }
     *   ... and so on for fails[NF].
     *
     *   // And so on the NS steps....
     */
    class RunAllErrorsAtAllSteps {
    public:
        /** The set of failures is hardcoded. */
        static constexpr std::array fails{Action::kErrTerminate,
                                          Action::kErrDisconnect,
                                          Action::kErrNetwork,
                                          Action::kErrShutdown,
                                          Action::kErrArbitrary};

        /** Encodes a response to `event` by taking `action`. */
        struct Step {
            Event event;
            Action action = Action::kDefault;
        };

        // The final step is assumed to have `kErrDisconnect` as an action,
        // yielding an implied `kEnd` step.
        RunAllErrorsAtAllSteps(SessionWorkflowTest* fixture, std::deque<Step> steps)
            : _fixture{fixture}, _steps{[&, at = steps.size() - 1] {
                  return _appendTermination(std::move(steps), at, Action::kErrDisconnect);
              }()} {}

        /**
         * Run all of the trials specified by the constructor.
         */
        void run() {
            const std::deque<Step> baseline(_steps.begin(), _steps.end());
            LOGV2(5014106, "Running one entirely clean run");
            _runSteps(baseline);
            // Incrementally push forward the step where we fail.
            for (size_t failAt = 0; failAt + 1 < baseline.size(); ++failAt) {
                LOGV2(6742614, "Injecting failures", "failAt"_attr = failAt);
                for (auto fail : fails)
                    _runSteps(_appendTermination(baseline, failAt, fail));
            }
        }

    private:
        /**
         * Returns a new steps sequence, formed by copying the specified `q`, and
         * modifying the copy to be terminated with a `fail` at the `failAt` index.
         */
        std::deque<Step> _appendTermination(std::deque<Step> q, size_t failAt, Action fail) const {
            LOGV2(
                6742617, "appendTermination", "fail"_attr = toString(fail), "failAt"_attr = failAt);
            invariant(failAt < q.size());
            q.erase(q.begin() + failAt + 1, q.end());
            q.back().action = fail;
            q.push_back({Event::kSepEndSession});
            return q;
        }

        template <typename T>
        void _dumpTransitions(const T& q) {
            BSONArrayBuilder bab;
            for (auto&& t : q) {
                BSONObjBuilder{bab.subobjStart()}
                    .append("event", toString(t.event))
                    .append("action", toString(t.action));
            }
            LOGV2(6742615, "Run transitions", "transitions"_attr = bab.arr());
        }

        /** Makes a result for a successful event. */
        Result _successResult(Event event, Action action) {
            switch (event) {
                case Event::kSepEndSession:
                    return Result{};
                case Event::kSessionWaitForData:
                case Event::kSessionSinkMessage:
                    return Result{Status::OK()};
                case Event::kSessionSourceMessage: {
                    Message m = makeOpMsg();
                    if (action == Action::kExhaust)
                        m = setExhaustSupported(m);
                    return Result{StatusWith{std::move(m)}};
                }
                case Event::kSepHandleRequest:
                    switch (action) {
                        case Action::kDefault:
                            return Result{StatusWith{makeResponse(makeOpMsg())}};
                        case Action::kExhaust:
                            return Result{StatusWith{setExhaust(makeResponse(makeOpMsg()))}};
                        case Action::kMoreToCome:
                            return Result{StatusWith{DbResponse{}}};
                        default:
                            MONGO_UNREACHABLE;
                    }
            }
            MONGO_UNREACHABLE;
        }

        void injectStep(const Step& t) {
            LOGV2_DEBUG(
                6872301, 3, "Inject step", "event"_attr = t.event, "action"_attr = t.action);
            switch (t.action) {
                case Action::kErrTerminate: {
                    // Has a side effect of simulating a ServiceEntryPoint shutdown
                    // before responding with a shutdown error.
                    auto pf = std::make_shared<PromiseAndFuture<void>>();
                    _fixture->injectMockResponse([this, t, pf](Event e) {
                        invariant(e == t.event);
                        _fixture->sep()->endAllSessionsNoTagMask();
                        pf->promise.emplaceValue();
                        return Result{kShutdownError};
                    });
                    pf->future.get();
                } break;
                case Action::kErrDisconnect:
                    _fixture->expect(t.event, Result{kClosedSessionError});
                    break;
                case Action::kErrNetwork:
                    _fixture->expect(t.event, Result(kNetworkError));
                    break;
                case Action::kErrShutdown:
                    _fixture->expect(t.event, Result(kShutdownError));
                    break;
                case Action::kErrArbitrary:
                    _fixture->expect(t.event, Result(kArbitraryError));
                    break;
                case Action::kDefault:
                case Action::kExhaust:
                case Action::kMoreToCome:
                    _fixture->expect(t.event, _successResult(t.event, t.action));
                    break;
            }
        }

        /** Start a new session, run the `steps` sequence, and join the session. */
        void _runSteps(std::deque<Step> q) {
            _dumpTransitions(q);
            _fixture->initializeNewSession();
            _fixture->startSession();
            for (; !q.empty(); q.pop_front())
                injectStep(q.front());
            _fixture->joinSessions();
        }

        SessionWorkflowTest* _fixture;
        std::deque<Step> _steps;
    };

    void runSteps(std::deque<RunAllErrorsAtAllSteps::Step> steps) {
        RunAllErrorsAtAllSteps{this, steps}.run();
    }

    std::deque<RunAllErrorsAtAllSteps::Step> defaultLoop() const {
        return {
            {Event::kSessionSourceMessage},
            {Event::kSepHandleRequest},
            {Event::kSessionSinkMessage},
            {Event::kSessionSourceMessage},
        };
    }

    std::deque<RunAllErrorsAtAllSteps::Step> exhaustLoop() const {
        return {
            {Event::kSessionSourceMessage, Action::kExhaust},
            {Event::kSepHandleRequest, Action::kExhaust},
            {Event::kSessionSinkMessage},
            {Event::kSepHandleRequest},
            {Event::kSessionSinkMessage},
            {Event::kSessionSourceMessage},
        };
    }

    std::deque<RunAllErrorsAtAllSteps::Step> moreToComeLoop() const {
        return {
            {Event::kSessionSourceMessage, Action::kMoreToCome},
            {Event::kSepHandleRequest, Action::kMoreToCome},
            {Event::kSessionSourceMessage},
            {Event::kSepHandleRequest},
            {Event::kSessionSinkMessage},
            {Event::kSessionSourceMessage},
        };
    }
};

class SessionWorkflowWithDedicatedThreadsTest : public StepRunnerSessionWorkflowTest {
    ScopedValueOverride<bool> _svo{gInitialUseDedicatedThread, true};
};

TEST_F(SessionWorkflowWithDedicatedThreadsTest, DefaultLoop) {
    runSteps(defaultLoop());
}

TEST_F(SessionWorkflowWithDedicatedThreadsTest, ExhaustLoop) {
    runSteps(exhaustLoop());
}

TEST_F(SessionWorkflowWithDedicatedThreadsTest, MoreToComeLoop) {
    runSteps(moreToComeLoop());
}

class SessionWorkflowWithBorrowedThreadsTest : public StepRunnerSessionWorkflowTest {
public:
    /**
     * Under the borrowed thread model, the steps are the same as for dedicated thread model,
     * except that Session sourceMessage events are preceded by Session waitForData events.
     */
    std::deque<RunAllErrorsAtAllSteps::Step> convertStepsToBorrowed(
        std::deque<RunAllErrorsAtAllSteps::Step> q) {
        for (auto iter = q.begin(); iter != q.end(); ++iter)
            if (iter->event == Event::kSessionSourceMessage)
                iter = std::next(q.insert(iter, {Event::kSessionWaitForData}));
        return q;
    }

private:
    ScopedValueOverride<bool> _svo{gInitialUseDedicatedThread, false};
};

TEST_F(SessionWorkflowWithBorrowedThreadsTest, DefaultLoop) {
    runSteps(convertStepsToBorrowed(defaultLoop()));
}

TEST_F(SessionWorkflowWithBorrowedThreadsTest, ExhaustLoop) {
    runSteps(convertStepsToBorrowed(exhaustLoop()));
}

TEST_F(SessionWorkflowWithBorrowedThreadsTest, MoreToComeLoop) {
    runSteps(convertStepsToBorrowed(moreToComeLoop()));
}

}  // namespace
}  // namespace mongo::transport
